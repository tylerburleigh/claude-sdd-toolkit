#!/bin/bash
#
# SessionStart Hook: SDD Project Status Detection
#
# This hook runs when a Claude Code session starts and outputs JSON describing:
# 1. Whether project needs SDD permission setup
# 2. Active spec files that can be resumed
#
# Claude reads this JSON and presents interactive options to the user.
#
# Hook behavior:
# - Exits silently if nothing to do
# - Outputs JSON if permissions needed or active specs found
# - No user interaction (Claude handles that)
# - Always non-blocking (exit 0)
#

set -euo pipefail

# Ensure SDD wrapper scripts are in PATH
export PATH="${HOME}/.claude/bin:$PATH"

# Configuration
PROJECT_ROOT=$(pwd)
SETTINGS_FILE="${HOME}/.claude/settings.json"
SPECS_ACTIVE_DIR="${PROJECT_ROOT}/specs/active"
MARKER_DIR="/tmp"
MARKER_PREFIX=".claude-sdd-begin"
TRANSCRIPT_CACHE_DIR="${HOME}/.config/claude-sdd-toolkit"
TRANSCRIPT_CACHE_FILE="${TRANSCRIPT_CACHE_DIR}/transcript-cache.json"

# =============================================================================
# TRANSCRIPT PATH CACHING
# =============================================================================
# Cache transcript paths per working directory so 'sdd context' can auto-discover them
# Handles multiple parallel Claude sessions by tracking per-directory

cache_transcript_path() {
    # Read hook data from stdin if available
    if [ ! -t 0 ]; then
        local hook_data=$(cat)

        # Extract transcript_path and session_id using Python, update multi-session cache
        local cache_data=$(echo "$hook_data" | python3 -c "
import json, sys, os, time

try:
    data = json.load(sys.stdin)
    transcript_path = data.get('transcript_path', '')
    session_id = data.get('session_id', '')
    cwd = os.getcwd()

    if transcript_path and session_id:
        # Get stable parent PID (PPID) for session identification
        # Import the utility function for finding the stable Claude process
        try:
            from claude_skills.context_tracker.process_utils import find_stable_claude_process
            stable_ppid = find_stable_claude_process()
        except ImportError:
            # Fallback if module not installed
            stable_ppid = None

        # Use stable PID if found, otherwise fallback to grandparent
        if stable_ppid:
            ppid = stable_ppid
        else:
            # Fallback: walk up 2 levels instead of immediate parent
            # This is more stable than immediate parent but not perfect
            ppid = os.getppid()
            try:
                if os.path.exists(f'/proc/{ppid}/status'):
                    with open(f'/proc/{ppid}/status', 'r') as f:
                        for line in f:
                            if line.startswith('PPid:'):
                                ppid = int(line.split()[1])
                                break
            except:
                pass  # Use immediate parent if this fails

        current_time = int(time.time())

        # Load existing cache
        cache_file = '$TRANSCRIPT_CACHE_FILE'
        cache = {}
        if os.path.exists(cache_file):
            try:
                with open(cache_file, 'r') as f:
                    cache = json.load(f)
            except:
                pass

        # Initialize directory entry if needed
        if cwd not in cache:
            cache[cwd] = {'sessions': {}}

        # Add/update this session with enhanced data
        session_data = {
            'transcript_path': transcript_path,
            'timestamp': current_time,
            'started_at': current_time,
            'ppid': ppid
        }

        cache[cwd]['sessions'][session_id] = session_data

        # Mark as most recent
        cache[cwd]['most_recent'] = session_id

        # Clean stale sessions (older than 1 hour with dead PIDs)
        sessions = cache[cwd].get('sessions', {})
        stale_session_ids = []
        for sid, sdata in sessions.items():
            spid = sdata.get('ppid')
            started = sdata.get('started_at', 0)
            age = current_time - started

            # Mark as stale if: has PPID, it's dead, and session > 1 hour old
            if spid and age > 3600:
                try:
                    os.kill(spid, 0)  # Check if process alive
                except (OSError, ProcessLookupError):
                    # Process is dead
                    stale_session_ids.append(sid)

        # Remove stale sessions
        for sid in stale_session_ids:
            del sessions[sid]

        # Update most_recent if it was removed
        if cache[cwd].get('most_recent') in stale_session_ids and sessions:
            # Set to session with highest timestamp
            cache[cwd]['most_recent'] = max(
                sessions.keys(),
                key=lambda s: sessions[s].get('timestamp', 0)
            )

        # Write cache
        os.makedirs('$TRANSCRIPT_CACHE_DIR', exist_ok=True)
        with open(cache_file, 'w') as f:
            json.dump(cache, f, indent=2)

        # Also set environment variable for this session
        print(f'CLAUDE_SESSION_ID={session_id}')
        print(f'CLAUDE_SESSION_PPID={ppid}')
except Exception as e:
    pass
" 2>/dev/null)

        if [ -n "$cache_data" ]; then
            # Try to export the session ID (may not work across processes, but worth trying)
            eval "$cache_data" 2>/dev/null || true
        fi

        # Re-populate stdin for rest of script (pass through hook_data)
        echo "$hook_data"
    fi
}

# =============================================================================
# CONFIGURATION LOADING
# =============================================================================

is_auto_offer_enabled() {
    if [ ! -f "$SETTINGS_FILE" ]; then
        echo "true"
        return
    fi

    python3 -c "
import json
try:
    with open('$SETTINGS_FILE', 'r') as f:
        settings = json.load(f)
    enabled = settings.get('sdd', {}).get('auto_offer_permissions', True)
    print('true' if enabled else 'false')
except:
    print('true')
" 2>/dev/null || echo "true"
}

# =============================================================================
# PERMISSION CHECKING
# =============================================================================

needs_permission_setup() {
    # Check if user previously declined (using local marker file)
    local declined_marker="${HOME}/.claude/.sdd-permissions-declined"
    if [ -f "$declined_marker" ]; then
        if grep -q "^$PROJECT_ROOT$" "$declined_marker" 2>/dev/null; then
            echo "false"
            return
        fi
    fi

    # Check if project needs setup
    local check_result=$(sdd skills-dev setup-permissions check "$PROJECT_ROOT" 2>/dev/null)
    local needs_setup=$(echo "$check_result" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    configured = data.get('configured', False)
    print('false' if configured else 'true')
except:
    print('false')
" 2>/dev/null)

    echo "$needs_setup"
}

# =============================================================================
# ACTIVE SPEC DETECTION
# =============================================================================

get_active_specs_json() {
    # Check if specs/active directory exists
    if [ ! -d "$SPECS_ACTIVE_DIR" ]; then
        echo "[]"
        return
    fi

    # Find all markdown files and build JSON array
    python3 <<EOF
import os
import json
import re

specs = []
spec_dir = "$SPECS_ACTIVE_DIR"

if os.path.exists(spec_dir):
    for filename in os.listdir(spec_dir):
        if filename.endswith('.md'):
            spec_file = os.path.join(spec_dir, filename)
            spec_id = filename[:-3]  # Remove .md extension

            # Try to determine status
            status = "unknown"
            try:
                with open(spec_file, 'r') as f:
                    content = f.read()
                    if re.search(r'status:\s*(?:in[-_\s]progress|pending)', content, re.IGNORECASE):
                        status = "has pending/in-progress tasks"
                    elif re.search(r'status:\s*completed', content, re.IGNORECASE):
                        status = "all tasks completed"
            except:
                pass

            specs.append({
                "spec_id": spec_id,
                "file": spec_file,
                "status": status
            })

print(json.dumps(specs))
EOF
}

# =============================================================================
# MARKER FILE MANAGEMENT
# =============================================================================

cleanup_old_markers() {
    # Remove marker files older than 1 hour
    find "$MARKER_DIR" -name "${MARKER_PREFIX}-*.json" -type f -mmin +60 -delete 2>/dev/null || true
}

create_marker_file() {
    local needs_perms=$1
    local active_specs_json=$2
    local system_msg=$3

    # Generate timestamp for unique filename
    local timestamp=$(date +%s)
    local marker_file="${MARKER_DIR}/${MARKER_PREFIX}-${timestamp}.json"

    # Convert bash true/false to Python True/False
    local py_bool="False"
    if [ "$needs_perms" = "true" ]; then
        py_bool="True"
    fi

    # Create marker file with JSON data using proper escaping
    python3 -c "
import json
import sys

marker = {
    'project_root': '''$PROJECT_ROOT''',
    'needs_permissions': $py_bool,
    'active_specs': $active_specs_json,
    'message': '''$system_msg''',
    'timestamp': $timestamp
}

print(json.dumps(marker, indent=2))
" > "$marker_file"
}

# =============================================================================
# MAIN LOGIC
# =============================================================================

main() {
    # Cache transcript path first (consumes stdin if available)
    cache_transcript_path >/dev/null

    # Clean up old marker files first
    cleanup_old_markers

    # Check if auto-offer is enabled
    if [ "$(is_auto_offer_enabled)" != "true" ]; then
        exit 0
    fi

    # FIRST: Check if this is an SDD project (has specs/active folder)
    if [ ! -d "$SPECS_ACTIVE_DIR" ]; then
        exit 0
    fi

    # Detect what's needed
    local needs_perms=$(needs_permission_setup)

    local active_specs_json=$(get_active_specs_json)
    local has_specs=$(echo "$active_specs_json" | python3 -c "import json, sys; print('true' if len(json.load(sys.stdin)) > 0 else 'false')")

    # If nothing to do, exit silently
    if [ "$needs_perms" != "true" ] && [ "$has_specs" != "true" ]; then
        exit 0
    fi

    # Build system message for user (visible in CLI)
    local system_msg=""

    if [ "$needs_perms" = "true" ]; then
        system_msg="📋 This project needs SDD permission setup. Run /sdd-begin to configure."
    fi

    if [ "$has_specs" = "true" ]; then
        # Add spec information to system message
        local spec_list=$(echo "$active_specs_json" | python3 -c "
import json, sys
specs = json.load(sys.stdin)
if specs:
    result = '📝 Active specs: ' + ', '.join([spec['spec_id'] for spec in specs])
    print(result)
" 2>/dev/null || echo "")

        if [ -n "$spec_list" ]; then
            if [ -n "$system_msg" ]; then
                system_msg="$system_msg | $spec_list"
            else
                system_msg="$spec_list. Run /sdd-begin to resume work."
            fi
        fi
    fi

    # Build additional context for Claude (not visible to user, but Claude can read it)
    local additional_context=""
    if [ "$needs_perms" = "true" ]; then
        additional_context="SDD project detected at $PROJECT_ROOT. Permissions not yet configured."
    fi
    if [ "$has_specs" = "true" ]; then
        local spec_details=$(echo "$active_specs_json" | python3 -c "
import json, sys
specs = json.load(sys.stdin)
if specs:
    details = ' Active specifications: '
    details += ', '.join([f\"{s['spec_id']} ({s['status']})\" for s in specs])
    print(details)
" 2>/dev/null || echo "")

        if [ -n "$additional_context" ]; then
            additional_context="$additional_context$spec_details"
        else
            additional_context="SDD project at $PROJECT_ROOT.$spec_details"
        fi
    fi

    # Convert bash booleans to Python format for marker file
    local py_needs_perms="false"
    if [ "$needs_perms" = "true" ]; then
        py_needs_perms="true"
    fi

    # Create marker file for Claude to read proactively
    create_marker_file "$py_needs_perms" "$active_specs_json" "$system_msg"

    # Also output JSON in the format Claude Code expects (for system message display)
    python3 <<EOF
import json

output = {
    "hookSpecificOutput": {
        "hookEventName": "SessionStart",
        "additionalContext": "$additional_context"
    }
}

# Only add systemMessage if we have one (it will be shown to user)
if "$system_msg":
    output["systemMessage"] = "$system_msg"

print(json.dumps(output, indent=2))
EOF

    exit 0
}

# Run main
main
